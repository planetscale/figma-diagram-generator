export class DBComponents {

    constructor() { }
  
    /** 
     * Creates small icons for rows in a table.
     * Generally in this program, this will be used to generate the small "PK" and "FK" icons.
     */
    static createKeyIcon(x: number, y:number, text:string, background: RGB) {
      const nodes: SceneNode[] = []; 
  
      const circle = figma.createRectangle();
      circle.cornerRadius = 5;
      circle.x = x;
      circle.y = y;
      circle.resize(30, 30);
      circle.fills = [{type: "SOLID", color: background}];
      figma.currentPage.appendChild(circle);
      nodes.push(circle);
  
      const key_text = figma.createText();
      key_text.x = x+2;
      key_text.y = y+2;
      key_text.fontSize = 20; 
      key_text.fontName =  { family: "Roboto Mono", style: "Bold" };
      key_text.characters = text;
      key_text.fills = [{ type: "SOLID", color:  {r: 0.0, g: 0.0, b:0.0}}]; 
      figma.currentPage.appendChild(key_text);
      nodes.push(key_text);
  
      return figma.group(nodes, figma.currentPage);
    }
  
    /**
     * Create the title rectangle for a table.
     * This rectangle has different styling than the regular column rows for 
     * differentiation and stylistic purposes.
     */
    static createTableTitleRect(x: number, y: number, name: string) {
      const nodes: SceneNode[] = []; 
  
      const rect = figma.createRectangle();
      rect.x = x;
      rect.y = y;
      rect.cornerRadius = 5;
      rect.resize(450, 50);
      rect.fills = [{ type: "SOLID", color: { r: 0.25, g: 0.25, b: 0.25 } }]; 
      figma.currentPage.appendChild(rect);
      nodes.push(rect);
  
      const row_name = figma.createText();
      row_name.x = x+20;
      row_name.y = y+10;
      row_name.fontSize = 20; 
      row_name.fontName =  { family: "Roboto Mono", style: "Bold" };
      row_name.characters = name;
      row_name.fills =  [{ type: "SOLID", color: {r: 0.8, g: 0.8, b:0.8}}]; 
      figma.currentPage.appendChild(row_name);
      nodes.push(row_name);
  
      return figma.group(nodes, figma.currentPage);
    }
    
    /**
     * Creates a rectangle to represent a column of a table on the diagram.
     * These rectangles will have different styling that the title rectangle.
     * Each row should include the column name, then the type, and then indicate
     * If this column is a foreign or primary key.
     */
    static createColumnRect(x: number, y: number, row: any) {
      const nodes: SceneNode[] = []; 
      
      const rect = figma.createRectangle();
      rect.x = x;
      rect.y = y;
      rect.cornerRadius = 5;
      rect.resize(450, 50);
      rect.fills = [{ type: "SOLID", color: { r: 0.1, g: 0.1, b: 0.1 } }]; 
      figma.currentPage.appendChild(rect);
      nodes.push(rect);
  
      const row_name = figma.createText();
      row_name.x = x+20;
      row_name.y = y+10;
      row_name.fontSize = 20; 
      row_name.fontName =  { family: "Roboto Mono", style: "Bold" };
      row_name.characters = row.column.column;
      row_name.fills =  [{ type: "SOLID", color: {r: 0.8, g: 0.8, b:0.8}}]; 
      figma.currentPage.appendChild(row_name);
      nodes.push(row_name);
  
      const row_type = figma.createText();
      row_type.x = x+200;
      row_type.y = y+10;
      row_type.fontSize = 20; 
      row_type.fontName = { family: "Roboto Mono", style: "Regular" };
      row_type.characters = row.definition.dataType;
      row_type.fills = [{ type: "SOLID", color: {r: 0.8, g: 0.3, b:0.2}}]; 
      figma.currentPage.appendChild(row_type);
      nodes.push(row_type);
  
      return figma.group(nodes, figma.currentPage);
    }
  
    /**
     * Create a rectangle with a transparent fill and a thin gray border at the specified location.
     */
    static createFrame(x: number, y:number, w:number, h:number) {
      const nodes: SceneNode[] = []; 
      const rect = figma.createRectangle();
      rect.x = x;
      rect.y = y;
      rect.cornerRadius = 5;
      rect.resize(w, h);
      rect.fills = [{ type: "SOLID", color: {r: 0.4, g: 0.4, b:0.4}, opacity: 0.0 }]; 
      rect.strokeWeight = 2;
      rect.strokes = [{ type: "SOLID", color: {r: 0.7, g: 0.7, b:0.7}, opacity: 1.0 }];
      rect.opacity = 1.0;
      figma.currentPage.appendChild(rect);
      nodes.push(rect);
      return figma.group(nodes, figma.currentPage);
    }
  
    /**
     * Connect two GroupNodes together with a FigJam connector.
     * The FigJam connectors "latch" to the elements they ar attached to.
     * Unfortunately, these "latched" connectors cannot be generated by the API
     * or UI for a regular Figma design file, but they *can* be copied over
     * from a FigJam file. Yeah. Thanks Figma.
     */
    static connectElements(from:GroupNode, to:GroupNode) {
      const connector = figma.createConnector();
      connector.connectorLineType = 'ELBOWED';
      connector.connectorStartStrokeCap = 'NONE';
      connector.connectorEndStrokeCap = 'NONE';
      connector.connectorStart = {endpointNodeId: from.id, magnet: 'AUTO' }
      connector.connectorEnd = { endpointNodeId: to.id, magnet: 'AUTO' }
    }
  
    /** 
     * This function is used to load fonts.
     * Call and ensure comp[letes before using any of these!
     */
    static loadFonts = async () => {
      await Promise.all([
        figma.loadFontAsync({ family: "Inter", style: "Regular" }),
        figma.loadFontAsync({ family: "Inter", style: "Medium" }),
        figma.loadFontAsync({ family: "Roboto Mono", style: "Bold" }),
        figma.loadFontAsync({ family: "Roboto Mono", style: "Regular" })]);
    }
  
    /**
     * Return true if this column in the table is a primary key, false otherwise.
     */
    static isPK(table_info:any, col_name:string) {
      for (let j = 0; j < table_info.create_definitions.length; j++) {
        let entry_k = table_info.create_definitions[j];
        if (entry_k.resource != 'constraint')
          continue;
        if (entry_k.definition[0].column != col_name)
          continue;
        if (entry_k.constraint_type == "primary key") {
          return true;
        }
      }
      return false;
    }
  
    /**
     * Check if the column name for the given table_info object has a foreign key.
     * If it does, return the name of the table and column that it refers to.
     * If not, return undefined.
     */
    static isFK(table_info:any, col_name:string) {
      for (let j = 0; j < table_info.create_definitions.length; j++) {
        let entry_k = table_info.create_definitions[j];
        if (entry_k.resource != 'constraint')
          continue;
        if (entry_k.definition[0].column != col_name)
          continue;
          if (entry_k.constraint_type == "FOREIGN KEY") {
            let fk_table = entry_k.reference_definition.table[0].table;
            let fk_column = entry_k.reference_definition.definition[0].column;
            return {"table": fk_table, "column": fk_column};
          }
      }
      return undefined;
    }
  }
  
